import csv
import re

counter = 0

with open('farorites.csv', 'r') as file:
    reader = csv.DictReader(file)
    for row in reader:
        title = row['title'].strip().upper()
        if re.search('office', title):
            counter += 1



################################### PROBLEM 1 ###################################

# HASH TABLE METHOD FOR UNSORTED ARRAY, SEE SORTED VERSION IN PROBLEM 167
# 3 SUM IN PROBLEM 15

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}                                     # key is the num, value is the index
        for i, num in enumerate(nums):
            if target - num in seen:
                return [i, seen[target- num]]
            seen[num] = i
        return []

This solution uses a hash table (dictionary in Python) to store the numbers as we iterate through the list.
For each number, we check if the target minus the current number is in the hash table. If it is, we have found our two numbers.
If not, we add the current number to the hash table and continue iterating.

Time complexity: O(n). We traverse the list containing nnn elements only once. Each lookup in the table costs only O(1) time.
Space complexity: O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements.


################################### PROBLEM 3 ###################################
Sliding Window

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        left = 0
        lookup = set()
        max_length = 0

        for right in range(len(s)):     # Since substring is continous, we need to delete all the characters
            while s[right] in lookup:   # before the found repeated char as well
                lookup.remove(s[left])
                left += 1
            lookup.add(s[right])
            max_length = max(max_length, right - left + 1)

        return max_length


################################### PROBLEM 5 ###################################

# Longest palindrome substring. See Problem 516 for longest palidrome subsequence.

# A substring is a contiguous non-empty sequence of characters within a string.
# A subsequence is a sequence that can be derived from another sequence by deleting some or no elements
#  without changing the order of the remaining elements.


class Solution:
    def longestPalindrome(self, s: str) -> str:

        res = ''
        max_length = 0

        for i in range(len(s)):
            # odd length
            left, right = i, i
            while left >= 0 and right < len(s) and s[left] == s[right]:
                if right - left + 1 > max_length:
                    max_length = right - left + 1
                    res = s[left:right+1]
                left -= 1
                right += 1
            left, right = i, i + 1

            # even length
            while left >= 0 and right < len(s) and s[left] == s[right]:
                if right - left + 1 > max_length:
                    max_length = right - left + 1
                    res = s[left:right+1]
                left -= 1
                right += 1

            # early stopping
            if len(s) - i <= max_length // 2:
                break

        return res




################################### PROBLEM 3 ###################################
Sliding Window

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

################################### PROBLEM 9 ###################################

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            # Negative integers cannot be palindromes
            return False

        # Determine the highest place value of x
        div = 1
        while x >= 10 * div:
            div *= 10

        while x:
            # Get the right-most digit of x
            right = x % 10
            # Get the left-most digit of x
            left = x // div

            if left != right:
                # If the left and right digits do not match, then x is not a palindrome
                return False

            # Remove the left and right digits from x
            x = (x % div) // 10
            # Update the highest place value of x
            div = div / 100

        # If the function has not returned False, then x is a palindrome
        return True


################################### PROBLEM 11 ###################################

TWO POINTERS

class Solution:
    def maxArea(self, height: List[int]) -> int:
        max_area = 0
        left = 0
        right = len(height) - 1

        while left < right:
            curr_area = (right - left) * min(height[left], height[right])
            max_area = max(max_area, curr_area)
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1

        return max_area

The time complexity of this solution is O(n), since we visit each vertical line at most once.
The space complexity is O(1), since we use a constant amount of extra space to store the pointers and the maximum area.

In order to maximize the area, we need to move the pointer that corresponds to the shorter line, because the area is limited by the shorter line.
If we move the pointer corresponding to the taller line, then the area will be limited by the shorter line at its new position,
and the area will not increase. However, if we move the pointer corresponding to the shorter line, then the area might increase,
because we might find a taller line to pair it with, and this taller line might increase the area.
Therefore, we always move the pointer that corresponds to the shorter line, and keep track of the maximum area we have seen so far.


We starts with the widest container, l = 0 and r = n - 1. Let's say the left one is shorter: h[l] < h[r].
Then, this is already the largest container the left one can possibly form. There's no need to consider it again.
Therefore, we just throw it away and start again with l = 1 and r = n -1.




################################### PROBLEM 15 ###################################

TWO POINTERS

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i-1]:    # skip duplicates
                continue

            left = i + 1                          # intialize two pointers
            right = len(nums) - 1

            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left - 1]:   # if there exists duplicates
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return res

# time: O(n^2), Space Complexity: O(logn) to O(n), depending on the implementation of the sorting algorithm.
For the purpose of complexity analysis, we ignore the memory required for the output.

-------------------------------------------
HASH SET

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i-1]:
                continue

            seen = set()
            for j in range(i+1, len(nums)):
                complement = -nums[i] - nums[j]
                if complement in seen:
                    res.append([nums[i], nums[j], complement])
                    while j < len(nums) - 1 and nums[j] == nums[j+1]:
                        j += 1

                seen.add(nums[j])

        return res



################################### PROBLEM 16 ###################################

TWO POINTERS

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        closest_sum = float('inf')

        for i in range(len(nums) - 2):
            left = i + 1
            right = len(nums) - 1
            while left < right:
                curr_sum = nums[i] + nums[left] + nums[right]
                if curr_sum == target:
                    return curr_sum
                elif curr_sum < target:
                    left += 1
                else:
                    right -= 1

                if abs(curr_sum - target) < abs(closest_sum - target):
                    closest_sum = curr_sum

        return closest_sum

# time: O(n^2) space: O(1), as we only use constant extra space to store the pointers and some variables.


################################### PROBLEM 17 ###################################

# backtrack

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []

        phone_dict = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl",
                   "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}

        output = []
        self.backtrack(phone_dict, digits, '', 0, output)
        return output

    def backtrack(self, phone_dict, digits, current_str, index, output):
        if index == len(digits):
            output.append(current_str)
            return

        for char in phone_dict[digits[index]]:
            self.backtrack(phone_dict, digits, current_str + char, index + 1, output)


The time complexity of this algorithm is O(3^N x 4^M), where N is the number of digits that map to 3 letters (2, 3, 4, 5, 6, 8),
and M is the number of digits that map to 4 letters (7, 9). The worst case is when all input digits map to 3 letters,
and all possible combinations need to be generated.

The space complexity is O(3^N x 4^M), as there are that many possible combinations, each of length N+M,
and all of them need to be stored in the result list.


################################### PROBLEM 20 ###################################

STACK

class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {")": "(", "}": "{", "]": "["}

        for str in s:
            if str in mapping:
                top_element = stack.pop() if stack else "#"
                if top_element != mapping[str]:
                    return False
            else:
                stack.append(str)
        return not stack


################################### PROBLEM 21 ###################################
Linked List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:

################################### PROBLEM 22 ###################################

# recursive backtracking approach, which is a form of depth-first search (DFS)

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        output = []
        self.backtrack(0, 0, '', n, output)

        return output

    def backtrack(self, open, close, current_str, maximum, output):
        # base case
        if len(current_str) == 2 * maximum:
            output.append(current_str)
            return

        if open < maximum:
            self.backtrack(open + 1, close, current_str + '(', maximum, output)
        if close < open:
            self.backtrack(open, close + 1, current_str + ')', maximum, output)


# time: O(4^n / n^(1/2)) space: O(n)


This is a backtrack solution for generating all valid parentheses combinations. Backtracking involves recursively building a solution and
undoing it when we reach a point where it is not valid. In this solution, we keep track of the number of opening and closing parentheses used so far
and backtrack if we reach a point where it is not possible to form a valid parentheses string.


################################### PROBLEM 33 ###################################
Search in rototed sorted array (distinct values)
See problem 81 for the case when there are duplicates

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)

        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid

            if nums[left] <= nums[mid]:                # left half is sorted
                if nums[left] <= target < nums[mid]:   # target might be in left half
                    right = mid
                else:
                    left = mid + 1
            else:                                      # right half is sorted
                if nums[mid] < target <= nums[right-1]:
                    left = mid + 1
                else:
                    right = mid

        return -1

################################### PROBLEM 34 ###################################
Binary Search

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]

        # start idx is the first position s.t. nums[mid] >= target
        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid
            else:
                left = mid + 1
        start = left

        # end idx is the last position s.t. nums[mid] == target (if any)
        #                first position s.t. nums[mid] > target. then return left - 1
        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > target:
                right = mid
            else:
                left = mid + 1
        end = left - 1

        return [start, end] if start <= end else [-1, -1]




################################### PROBLEM 35 ###################################


class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        # find the first index s.t. nums[mid] > target

        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid
            else:
                left = mid + 1

        return left



################################### PROBLEM 36 ###################################
Hashset

key: (r/3, c/3), value: set()

class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = collections.defaultdict(set)
        rows = collections.defaultdict(set)
        squares = collections.defaultdict(set)   # key = (r / 3, row / 3)

        for r in range(9):
            for c in range(9):
                if board[r][c] == '.':
                    continue
                if (board[r][c] in rows[r] or
                    board[r][c] in cols[c] or
                    board[r][c] in squares[(r // 3, c // 3)]):
                    return False
                cols[c].add(board[r][c])
                rows[r].add(board[r][c])
                squares[(r//3, c//3)].add(board[r][c])

        return True

# Time: O(9^2)

################################### PROBLEM 39 ###################################

Given an array of DISTINCT integers, return a list of all UNIQUE combinations
Same number can be chosen UNLIMITED times. See problem 40 for another version
BACKTRACK

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        output = []
        self.backtrack(candidates, 0, target, [], output)
        return output

    def backtrack(self, candidates, start, remaining, tmp_lst, output):
        if remaining == 0:
            output.append(tmp_lst)
            return
        elif remaining < 0:
            return
        else:
            for i in range(start, len(candidates)):
                self.backtrack(candidates, i, remaining - candidates[i], tmp_lst + [candidates[i]], output)


################################### PROBLEM 40 ###################################
Given an array of integers (could have duplicates), return a list of all unique combinations
Each number may only be selected ONCE.
See problem 216 for the third version.

class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        output = []
        self.backtrack(candidates, 0, target, [], output)
        return output

    def backtrack(self, candidates, start, remaining, tmp_lst, output):
        if remaining == 0:
            output.append(tmp_lst)
            return
        elif remaining < 0:
            return
        else:
            for i in range(start, len(candidates)):
                if i > start and candidates[i] == candidates[i-1]:
                    continue
                self.backtrack(candidates, i+1, remaining - candidates[i], tmp_lst + [candidates[i]], output)


################################### PROBLEM 46 ###################################
Array of distinct integers.

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        output = []
        self.backtrack(nums, [], output)
        return output

    def backtrack(self, nums, tmp_lst, output):
        if not nums:
            output.append(tmp_lst)
            return
        for i in range(len(nums)):
            self.backtrack(nums[:i]+nums[i+1:], tmp_lst+[nums[i]], output)

# Another way
# def backtrack(self, nums, tmp_list, output):
#     if len(tmp_list) == len(nums):
#         output.append(tmp_list[:])
#         return
#     else:
#         for num in nums:
#             if num in tmp_list:
#                 continue
#             tmp_list.append(num)
#             self.backtrack(nums, tmp_list, output)
#             tmp_list.pop()

################################### PROBLEM 47 ###################################
Array of integers, that might contain duplicates.

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        output = []
        self.backtrack(nums, [], output)
        return output

    def backtrack(self, nums, tmp_lst, output):
        if not nums:
            output.append(tmp_lst)
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            self.backtrack(nums[:i]+nums[i+1:], tmp_lst + [nums[i]], output)


################################### PROBLEM 69 ###################################

class Solution:
    def mySqrt(self, x: int) -> int:
        # find the smallest integer n, s.t. n * n > x

        if x <= 1:
            return x

        left, right = 0, x
        while left < right:
            mid = left + (right - left) // 2
            if mid * mid == x:
                return mid
            elif mid * mid > x:
                right = mid
            else:
                mid = left + 1

        return left - 1




################################### PROBLEM 71 ###################################
Stack

class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        curr = ''

        for char in path + '/':
            if char == '/':
                if curr == '..':                    # if we meet '..', we go up a level
                    if stack:
                        stack.pop()
                elif curr != '' and curr != '.':    # if is a char, append to the stack
                    stack.append(curr)
                curr = ''                           # reset to empty string
            else:
                curr += char

        return  '/' + '/'.join(stack)

################################### PROBLEM 74 ###################################
Binary Search

Note how we get the mid_val based on cols

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False

        rows, cols = len(matrix), len(matrix[0])

        left, right = 0, rows * cols

        while left < right:
            mid = left + (right - left) // 2
            mid_row = mid // cols
            mid_col = mid % cols
            mid_val = nums[mid_row][mid_col]
            if mid_val == target:
                return True
            elif mid_val > target:
                right = mid
            else:
                left = mid + 1

        return False


# time: O(log(m+n))

################################### PROBLEM 76 ###################################
Sliding Window (Hard)

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == "":
            return ""

        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        have, need = 0, len(countT)
        res = [-1, -1]
        res_length = float('inf')
        left = 0

        for right in range(len(s)):
            c = s[right]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:    # first time match
                have += 1

            while have == need:
                # update our result
                if (right - left + 1) < res_length:
                    res = [left, right]
                    res_length = (right - left + 1)
                # pop from the left of our window
                window[s[left]] -= 1
                if s[left] in countT and window[s[left]] < countT[s[left]]:
                    have -= 1

                left += 1

        left, right = res
        return s[left:right + 1] if res_length != float('inf') else ""




################################### PROBLEM 77 ###################################
BACKTRACK

class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        output = []
        self.backtrack(n, k, 1, [], output)
        return output

    def backtrack(self, n, k, start, tmp_lst, output):
        if len(tmp_lst) == k:
            output.append(tmp_lst)
            return
        for i in range(start, n+1):
            self.backtrack(n, k, i+1, tmp_lst+[i], output)

################################### PROBLEM 78 ###################################
BACKTRACK

# Array of UNIQUE element, return all possible subsets
# See 90 for a different version

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        output = []
        self.backtrack(nums, [], output)
        return output

    def backtrack(self, nums, tmp_lst, output):
        output.append(tmp_lst)
        for i in range(len(nums)):
            self.backtrack(nums[i+1:], tmp_lst+[nums[i]], output)



################################### PROBLEM 79 ###################################
BACKTRACK

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        rows, cols = len(board), len(board[0])

        for i in range(rows):
            for j in range(cols):
                # if the current cell matches the first letter of the word, start the search
                if board[i][j] == word[0]:
                    if self.backtrack(board, word, i, j, 0):      # Note here idx start from 0
                        return True

        # if the word is not found, return False
        return False

    def backtrack(self, board, word, i, j, idx):
        # base case: if we've found all the letters in the word, return True
        if idx == len(word):
            return True

        # if we're out of bounds or the current cell doesn't match the current letter of the word, return False
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[idx]:
            return False

        ####### if we are here, it means board[i][j] = word[idx]
        tmp = board[i][j]
        # mark the current cell as visited
        board[i][j] = '#'

        # search in all four directions for the next letter in the word
        res = self.backtrack(board, word, i-1, j, idx+1) or \
              self.backtrack(board, word, i+1, j, idx+1) or \
              self.backtrack(board, word, i, j-1, idx+1) or \
              self.backtrack(board, word, i, j+1, idx+1)

        # unmark the current cell
        board[i][j] = tmp

        return res



################################### PROBLEM 81 ###################################
Binary Search

class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums)

        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return True

            if nums[left] < nums[mid]:     # left half is sorted
                if nums[left] <= target < nums[mid]:
                    right = mid
                else:
                    left = mid + 1
            elif nums[left] > nums[mid]:   # right half is sorted
                if nums[mid] < target <= nums[right-1]:
                    left = mid + 1
                else:
                    right = mid
            else:                          # we couldn't tell which half is sorted
                left += 1

        return False


The main difference in this problem is that the input array is allowed to have duplicates,
so we need to add an additional case to handle when nums[mid] == nums[left].
In this case, we can't determine which side of the array is sorted, so we just increment
left by 1 and continue the loop.



################################### PROBLEM 84 ###################################
Monotonic Stack (Hard)   https://www.youtube.com/watch?v=zx5Sw9130L0&t=1s
#


class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        max_area = 0
        stack = []   # pair: (index, height), the index is the staring index which height can extend to

        for i, h in enumerate(heights):
            start = i
            while stack and stack[-1][1] > h:
                index, height = stack.pop()
                max_area = max(max_area, height * (i - index))
                start = index
            stack.append((start, h))

        for i, h in stack:
            max_area = max(max_area, h * (len(heights) - i))

        return max_area


#  Time: O(n), space: O(n)
################################### PROBLEM 88 ###################################

TWO POINTERS. FOR MORE THAN TWO ARRAYS, CAN USE HEAP.

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # Initialize pointers for nums1, nums2, and the merged result
        i = m - 1         # Pointer for nums1
        j = n - 1         # Pointer for nums2
        cur = m + n - 1   # # Pointer for the merged result

        # Merge nums1 and nums2 from the end to the beginning
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[cur] = nums1[i]
                i -= 1
            else:
                nums1[cur] = nums2[j]
                j -= 1
            cur -= 1

        # Copy the remaining elements from nums2, if any
        if j >= 0:
            nums1[:(j+1)] = nums2[:(j+1)]


In this solution, we start with three pointers: i points to the last element in nums1, j points to the last element in nums2,
and k points to the last empty slot in nums1. We then compare the elements at nums1[i] and nums2[j] and place the larger one at nums1[k],
moving the corresponding pointer back one slot. We repeat this until all elements from both arrays have been placed in the merged result.
Finally, if there are any elements remaining in nums2 after all elements from nums1 have been merged, we copy them over to the beginning of nums1.
Note that this solution modifies nums1 in place and does not return a new array.

The time complexity of this solution is O(m+n), where m and n are the lengths of nums1 and nums2, respectively.
This is because we traverse each element in nums1 and nums2 exactly once.

The space complexity is O(1), since we are modifying nums1 in place and are not using any extra data structures.
We only use a few pointers and variables to keep track of our progress in merging the two arrays,
so the amount of memory we use is constant with respect to the size of the input.


# When merging more than 2 sorted arrays

Input: nums1 = [2,4,6,0,0,0], m = 3, nums2 = [1,7], n = 3, nums3 = [9], p = 1
Output: [1,2,4,6,7,9]

import heapq   # by default, Min Heap is implemented by this class
# if change nums1 in place, have to fill in nums1 from the end and use Max Heap

def merge_three(nums1, m, nums2, n, nums3, p):
    """
    Merge three sorted arrays into nums1.  USING MAX HEAP
    """
    heap = [(-nums1[m-1], m-1, nums1), (-nums2[n-1], n-1, nums2), (-nums3[p-1], p-1, nums3)]
    heapq.heapify(heap)

    for i in range(m+n+p-1, -1, -1):
        val, idx, arr = heapq.heappop(heap)
        nums1[i] = -val

        if idx - 1 > 0:
            heapq.heappush(heap, (-arr[idx-1], idx-1, arr))

# time: O((m+n+p)log(k)), space:O(1)

# Use min heap directly, we have to create a variable to save the result
def merge_three(nums1, m, nums2, n, nums3, p):
    """
    Merge three sorted arrays into nums1.  USING MAX HEAP
    """
    res = []
    heap = [(nums1[0], 0, nums1), (nums2[0], 0, nums2), (nums3[0], 0, nums3)]
    heapq.heapify(heap)

    for i in range(m+n+p):
        val, idx, arr = heapq.heappop(heap)
        res.append(val)

        if idx < len(arr) - 1:
            heapq.heappush(heap, (arr[idx+1], idx+1, arr))

    return res

# time: O((m+n+p)log(k)), space:O((m+n+p))



################################### PROBLEM 90 ###################################
# Array that may contain duplicates, return all possible subsets
# returned result can't contain duplicates
# See 78 for another version

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        output = []
        self.backtrack(nums, [], output)
        return output

    def backtrack(self, nums, tmp_lst, output):
        output.append(tmp_lst)
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            self.backtrack(nums[i+1:], tmp_lst+[nums[i]], output)


Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
if no skip: [[],[1],[1,2],[1,2,2],[1,2],[2],[2,2],[2]]

################################### PROBLEM 121 ###################################

DP

class Solution:
    def maxProfit(self, prices: List[int]) -> int:   # one transaction only
        min_price = float('inf')
        max_profit = 0

        for price in prices:
            if price < min_price:
                min_price = price
            else:
                max_profit = max(max_profit, price - min_price)

        return max_profit


# time: O(n) Space: O(1)

For each price in the array:
a. If price is less than min_price, update min_price
b. Else, update max_profit as max(max_profit, price - min_price)


################################### PROBLEM 122 ###################################

METHOD 1: Peak Valley Approach. Consider every peak immediately following a valley to maximize the profit.


class Solution:
    def maxProfit(self, prices: List[int]) -> int:  # infinite transactions
        if len(prices) <= 1:
            return 0

        max_profit = 0
        valley = prices[0]
        peak = prices[0]

        i = 0
        while i < len(prices) - 1:
            while i < len(prices) - 1 and prices[i] >= prices[i+1]:
                i += 1
            valley = prices[i]
            while i < len(prices) - 1 and prices[i] <= prices[i+1]:
                i += 1
            peak = prices[i]
            max_profit += peak - Valley

        return max_profit

 # identify the valley (local minimum) and peak (local maximum) in the price curve, and buy at the valley and sell at the peak.

----------------------------------------------
METHOD 2:  Simple One Pass

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0

        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                max_profit += prices[i] - prices[i-1]

        return max_profit

################################### PROBLEM 123 ###################################

# build two DP, left to right and right to left.

class Solution:
    def maxProfit(self, prices: List[int]) -> int:    # at most 2 transactions
        n = len(prices)
        left_profit = [0] * n
        right_profit = [0] * n

        left_min = prices[0]
        right_max = prices[-1]

        for i in range(1, n):
            if prices[i] < left_min:
                left_min = prices[i]
            left_profit[i] = max(left_profit[i-1], prices[i] - left_min)

            if prices[n-i-1] > right_max:
                right_max = prices[n-i-1]
            right_profit[n-i-1] = max(right_profit[n-i], right_max - prices[n-i-1])

        right_profit.append(0)
        max_profit = 0
        for i in range(n):
            max_profit = max(max_profit, left_profit[i] + right_profit[i+1])   # this one is like we "You are only allowed to initiate a second transaction on a later day."
            #  HERE, max_profit = max(max_profit, left_profit[i] + right_profit[i]) would also work, since we can sell and buy at the same day
        return max_profit


################################### PROBLEM 125 ###################################
class Solution:
    def isPalindrome(self, s: str) -> bool:
        res = ''
        for char in s:
            if char.isalnum():    # if char.isalpha() or char.isdigit()
                res += char.lower()

        return res == res[::-1]

# time: O(n) space O(n)


TWO POINTERS, no extra space
class Solution:
    def isPalindrome(self, s: str) -> bool:
        if not s:
            return True

        left = 0
        right = len(s) - 1

        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            if left < right and s[left].lower() != s[right].lower():
                return False
            left -= 1
            right += 1

        return True

# time: O(n), space: O(1)


################################### PROBLEM 130 ###################################
DFS

# Check all the boarders, and

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows, cols = len(board), len(board[0])

        for i in range(rows):
            for j in range(cols):
                if (i in [0, rows-1] or j in [0, cols-1]) and board[i][j] == 'O':
                    self.dfs(board, i, j)

        for i in range(rows):
            for j in range(cols):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == '#':
                    board[i][j] = 'O'

    def dfs(self, board, i, j):

        # WRONG ONE:     if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] == 'X':

        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':
            return

        board[i][j] = '#'

        self.dfs(board, i-1, j)
        self.dfs(board, i+1, j)
        self.dfs(board, i, j-1)
        self.dfs(board, i, j+1)


Note here the edge condition is check board[i][j] != 'O', since we are updating the board, could be 'O', 'X', '#'.

################################### PROBLEM 131 ###################################
BACKTRACK

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        output = []
        self.backtrack(s, 0, [], output)
        return output

    def backtrack(self, s, start, tmp_lst, output):
        if start == len(s):
            output.append(tmp_lst)
            return

        else:
            for i in range(start, len(s)):
                if self.is_palindrome(s[start:i+1]):
                    self.backtrack(s, i+1, tmp_lst + [s[start:i+1]], output)

    def is_palindrome(self, s):
        return s == s[::-1]





################################### PROBLEM 143 ###################################
Linked List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """



################################### PROBLEM 150 ###################################
Stack

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token not in '+-*/':
                stack.append(int(token))
                continue

            num2 = stack.pop()
            num1 = stack.pop()

            res = 0
            if token == '+':
                result = num1 + num2
            elif token == '-':
                result = num1 - num2
            elif token == '*':
                result = num1 * num2
            else:
                result = int(num1 / num2)

            stack.append(result)

        return stack.pop()

# Method 2: Using lambda function

class Solution:
      def evalRPN(self, tokens: List[str]) -> int:

          operations = {
              "+": lambda a, b: a + b,
              "-": lambda a, b: a - b,
              "/": lambda a, b: int(a / b),
              "*": lambda a, b: a * b
          }

          stack = []
          for token in tokens:
              if token in operations:
                  number_2 = stack.pop()
                  number_1 = stack.pop()
                  operation = operations[token]
                  stack.append(operation(number_1, number_2))
              else:
                  stack.append(int(token))
          return stack.pop()
################################### PROBLEM 153 ###################################
Find Minimum in Rotated Sorted Array

class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid

        return nums[left]

The given code works because it utilizes the property of the rotated sorted array, where the smallest element in the array
is the only one that is smaller than its previous element.

By comparing the middle element to the last element in the array, the code can determine which half of the array to search
for the smallest element. If the middle element is greater than the last element, the smallest element must be in the second
 half of the array, so the left pointer is moved to the middle + 1. If the middle element is less than or equal to the last
 element, the smallest element must be in the first half of the array, so the right pointer is moved to the middle.

The search continues until the left and right pointers meet, which will be at the index of the smallest element in the array.


################################### PROBLEM 155 ###################################
Stack

# One stack to keep the order and nums, another stack to keep the minimum value so far

class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        min_val = min(val, self.min_stack[-1] if self.min_stack else val)
        self.min_stack.append(min_val)

        """
        if not stack:
            self.stack.append(val)
            self.min_stack.append(val)
        else:
            if val < self.min_stack[-1]:
                self.min_stack.append(val)
            else:
                self.min_stack.append(self.min_stack[-1])
            self.stack.append(val)
        """
    def pop(self) -> None:
        self.min_stack.pop()
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

################################### PROBLEM 162 ###################################
Binary Search

class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        # find the first index s.t. nums[mid] < nums[mid - 1], where mid-1 in the index of maximum

        left, right = 0, len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < nums[mid-1]:
                right = mid
            else:
                left = mid + 1

        return left - 1

################################### PROBLEM 167 ###################################

# TWO POINTERS. SEE PROBLEM 1 FOR UNSORTED VERSION

def twoSum(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        curr_sum = nums[left] + nums[right]
        if curr_sum == target:
            return [left, right]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
    return []


  In this approach, two pointers are initialized, one at the beginning of the array (left) and one at the end of the array (right).
  The sum of the values at these two pointers (curr_sum) is calculated and compared to the target sum.
  If curr_sum is equal to the target sum, the indices of the two numbers are returned. If curr_sum is less than the target sum,
  the left pointer is moved to the right. If curr_sum is greater than the target sum, the right pointer is moved to the left.
  This process continues until either the two pointers meet or the target sum is found.

The time complexity of the two-pointer solution for the Two Sum problem is O(n), where n is the length of the input array.
This is because the solution iterates through the array once with two pointers.
The while loop continues until the left pointer is equal to or greater than the right pointer, so the maximum number of iterations is n/2.

The space complexity of the solution is O(1), as it only requires a few variables to store the pointers and the current sum, and it does not use any additional data structures such as a hash table.

This solution has a better time complexity compared to the hash table solution, which has a time complexity of O(n) and a space complexity of O(n).
However, the hash table solution is more straightforward to implement and may be preferred in practice, especially if the input array is not sorted.


################################### PROBLEM 188 ###################################

dp[day_number][used_transaction_number][stock_holding_status]
1. keep holding the stock           dp[i][j][1] = dp[i-1][j][1]
2. keep not holding the stock       dp[i][j][0] = dp[i-1][j][0]
3. buy the stock                    dp[i][j][1] = dp[i-1][j-1][0] - prices[i]
4. sell the stock                   dp[i][j][0] = dp[i-1][j][1] + prices[i]



class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:  # at most k transactions
        n = len(prices)

        if 2 * k > n:  # can do unlimit transactions
            max_profit = 0
            for i in range(1, n):
                if prices[i] > prices[i-1]:
                    max_profit += prices[i] - prices[i-1]
            return max_profit

        dp = [[[float('-inf')] * 2 for _ in range(k+1)] for _ in range(n)]     # ses a list comprehension to create a 3D arrays

        dp[0][0][0] = 0
        dp[0][1][1] = -prices[0]

        for i in range(1, n):
            for j in range(k+1):
                dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])     # selling stock doesn't count as a new transaction!!!
                if j > 0:
                    dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])

        max_profit = max(dp[n-1][j][0] for j in range(k+1))

        return max_profit

# time: O(nk)  space:O(nk)


################################### PROBLEM 200 ###################################
Method 1: DFS

class Solution:                                # change in place, might not favorable for some cases
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or len(grid[0]) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])

        count = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1':
                    count += 1
                    self.dfs(grid, i, j)        # find all the connected '1', and marked as '0', in-place change

        return count

    def dfs(self, grid, i, j):                  #
        if i == -1 or i = len(grid) or j == -1 or j == len(grid[0]) or grid[i][j] == '0':
            return

        grid[i][j] = '0'                         # mark as visited

        self.dfs(grid, i-1, j)
        self.dfs(grid, i+1, j)
        self.dfs(grid, i, j-1)
        self.dfs(grid, i, j+1)

class Solution:                                # use extra space to save visited
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or len(grid[0]) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])
        visited = [[False for _ in range(cols)] for _ in range(rows)]

        count = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1' and not visited[i][j]:
                    count += 1
                    self.dfs(grid, visited, i, j)

        return count

    def dfs(self, grid, i, j):                  #
        if i == -1 or i == len(grid) or j == -1 or j == len(grid[0]) or grid[i][j] == '0' or visited[i][j]:
            return

        visited[i][j] = True                       # mark as visited

        self.dfs(grid, visited, i-1, j)
        self.dfs(grid, visited, i+1, j)
        self.dfs(grid, visited, i, j-1)
        self.dfs(grid, visited, i, j+1)

# time: O(mn), since we visit each cell as most once
# space: O(mn), for the visited matrix

Method 2: BFS + QUEUE
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0

        rows, cols = len(grid), len(grid[0])
        visited = set()
        count = 0

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1' and (i, j) not in visited:
                    count += 1
                    queue = [(i, j)]
                    visited.add((i, j))

                    while queue:
                        row, col = queue.pop(0)

                        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                            new_row, new_col = row + dx, col + dy

                            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == '1' and (new_row, new_col) not in visited:
                                queue.append((new_row, new_col))
                                visited.add((new_row, new_col))
        return count


################################### PROBLEM 206 ###################################

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# iteratively time: O(n), space: O(1)
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev, curr = None, head

        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt
        return prev

# recursively time: O(n), space: O(n)

################################### PROBLEM 209 ###################################


class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:

        n = len(nums)
        if n == 0
            return 0

        min_length = float(inf)
        curr_sum = 0
        left, right = 0, 0

        while right < n:
            curr_sum += nums[right]
            while curr_sum >= target:
                curr_length = right - left + 1
                if curr_length < min_length:
                    min_length = curr_length
                curr_sum -= nums[left]
                left += 1
            right += 1

        return min_length if min_length != float('inf') else 0


################################### PROBLEM 216 ###################################
BACKTRACK

class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        nums = [1,2,3,4,5,6,7,8,9]

        output = []
        self.backtrack(nums, k, n, [], output)
        return output

    def backtrack(self, nums, num_remaining, sum_remaining, tmp_lst, output):
        if nums_remaining == 0 and sum_remaining == 0:
            output.append(tmp_lst)
            return output
        elif nums_remaining < 0 or sum_remaining < 0:
            return
        else:
            for i in range(len(nums)):
                self.backtrack(nums[i+1:], num_remaining-1, sum_remaining-nums[i], tmp_lst + [nums[i]], output)


################################### PROBLEM 217 ###################################
See Problem 219 and 220 for extensions
Hashset. No need to use dictionary here, don't need to keep the count

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hashset = set()

        for num in nums:
            if num in hashset:
                return True
            hashset.add(num)

        return False

# time: O(n), space: O(n)

################################### PROBLEM 219 ###################################
Sliding Window + Hast Table

class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        window = set()
        left = 0

        for right in range(len(nums)):
            if right - left > k:
                window.remove(nums[left])
                left += 1

            if nums[right] in window:
                return True
            window.add(nums[right])

        return False


# time: O(n), space: O(k)

################################### PROBLEM 220 ###################################
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:



################################### PROBLEM 225 ###################################
STACK

from collections import deque
class MyStack:

    def __init__(self):
        self.q = deque()


    def push(self, x: int) -> None:
        self.q.append(x)

    def pop(self) -> int:
        for i in range(len(self.q) - 1):
            # self.q.append(self.q.popleft())
            self.push(self.q.popleft)
        return self.q.popleft()

    def top(self) -> int:
        return self.q[-1]

    def empty(self) -> bool:
        return len(self.q) == 0


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()



################################### PROBLEM 232 ###################################
QUEUE

s1 is the main stack, when pushing a new element,
1. we pop all the s1, and append to s2.
2. append new element to the s1.
3. pop all the s2, and append to s1.

class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x: int) -> None:
        while self.s1:
            self.s2.append(self.s1.pop())

        s1.append(x)

        while self.s2:
            self.s1.append(self.s2.pop())

    def pop(self) -> int:
        return self.s1.pop()

    def peek(self) -> int:
        return self.s1[-1]

    def empty(self) -> bool:
        return len(self.s1) == 0


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()


################################### PROBLEM 238 ###################################
Prefix Sum

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        pre_product = [1] * len(nums)
        suf_product = [1] * len(nums)

        for i in range(1, len(nums)):
            pre_product[i] = pre_product[i-1] * nums[i-1]

        for i in range(len(nums)-2, -1, -1):
            suf_product[i] = suf_product[i+1] * nums[i+1]

        res = [None] * len(nums)
        for i in range(len(nums)):
            res[i] = pre_product[i] * suf_product[i]

        return res

# time: O(n), space: O(n)

Follow up: Can you solve the problem in O(1) extra space complexity?
(The output array does not count as extra space for space complexity analysis.)

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * len(nums)

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]

        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]

        return res

################################### PROBLEM 240 ###################################
Can start from the topright or bottomleft element

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix:
            return False

        m, n = len(matrix), len(matrix[0])
        i, j = 0, n - 1

        while i < m and j >= 0:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                i += 1
            else:
                j -= 1

        return False


################################### PROBLEM 242 ###################################

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        """
        Method 1: time: O(s+t), space: O(s+t)
        """
        if len(s) != len(t):
            return False

        countS, countT = {}, {}

        for i in range(len(s)):
            countS[s[i]] = countS.get(s[i], 0) + 1
            countT[t[i]] = countT.get(t[i], 0) + 1

        for c in countS:
            if countS[c] != countT.get(c, 0):          # Just in case c is not in countT
                return False

        return True

        # one liner: return Counter(s) == Counter(t)

        """
        Method 2: time: O(n log(n)), space: O(1)
        """
        return sorted(s) == sorted(t)


################################### PROBLEM 252 ###################################
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:

        if len(intervals) <= 1:
            return True

        sorted_intervals = sorted(intervals, key = lambda x: (x[0], x[1]))

        for i in range(1, len(intervals)):
            if sorted_intervals[i-1][1] < sorted_intervals[i][0]:
                return False

        return True

# Time: O(n)


################################### PROBLEM 253 ###################################
Sort OR Heap

Return the maximum number of overlapping meetings at any given time

class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
################################### PROBLEM 259 ###################################

class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        count = 0
        nums.sort()

        for i in range(len(nums) - 2):
            j = i + 1
            k = len(nums) - 1

            if nums[i] + nums[j] + nums[k] < target:
                count += k - j    # tricky here! if the three sum is less than target, then all the number between j and k would counts
                                  # i,j, (j+1, j+2, j+3, ..., k)
                j += 1
            else:
                k -= 1

        return count

################################### PROBLEM 274 ###################################
Input is not sorted, see problem 275 for the sorted input

class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        freq = {}
        for c in citations:
            # since h <= n, don't need to count the citation whici larger than n
            freq[min(c, n)] = freq.get(min(c, n), 0) + 1

        h = 0
        for i in range(n, -1, -1):
            h += freq.get(i, 0)
            if h >= i:
                return i

        return 0


################################### PROBLEM 275 ###################################
Binary Search

find the first index s.t. nums[mid] >= n - mid, return n - left

class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        left, right = 0, n

        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] >= n - mid:
                right = mid
            else:
                left = mid + 1

        return n - left



################################### PROBLEM 278 ###################################
Binary Search

# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

# Find the first index such such isBadVersion(mid) == True

class Solution:
    def firstBadVersion(self, n: int) -> int:
        left, right = 0, n

        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left

################################### PROBLEM 287 ###################################
# Linked List + Floyd's Tortoise and Hare (Cycle Detection)

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = 0, 0

        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        slow2 = 0
        while True:
            slow = nums[slow]
            slow2 = nums[slow2]
            if slow == slow2:
                return slow

# time: O(n), space: O(1)

################################### PROBLEM 295 ###################################

# maintain two balanced heaps, one storing the smaller half, another storing the larger half

import heapq

class MedianFinder:
    def __init__(self):
        self.left_heap = []   # storing the smaller half, use max heap
        sefl.rigth_heap = []  # storing the larger half, use min heap

    def addNum(self, num):
        # push the num to the heap
        if len(self.left_heap) == 0 or num < -self.left_heap[0]:
            heapq.heappush(self.left_heap, -num)
        else:
            heapq.heappush(self.right_heap, num)

        # balance two heaps
        if len(self.left_heap) < len(self.right_heap):
            tmp = heapq.heappop(self.right_heap)
            heapq.heappush(self.left_heap, -num)
        elif len(self.left_heap) == len(self.right_heap) + 2:
            tmp = heapq.heappop(self.left_heap)
            heapq.heappush(self.right_heap, -tmp)

    def findMeidan(self):
        if len(self.left_heap) > len(self.right_heap):
            return -self.left_heap[0]
        else:
            return (-self.left_heap[0] + self.right_heap[0]) / 2


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()

# time: add a num to a heap is O(log n), find median is O(1)
# space: O(n) to save all the input

If the size of the data stream is very large and we cannot save all the data into the memory, we can use an external sorting algorithm to
sort the data in chunks and then merge the chunks using a merge algorithm. In this way, we can sort the data without storing all of it in memory.
After sorting the data, we can use the two-pointer approach or binary search to find the median. Another approach is to use a probabilistic data
structure such as a Bloom filter to approximate the median. However, the approximate median may not be accurate, and the accuracy depends on the
size of the filter and the number of hash functions used.

################################### PROBLEM 300 ###################################
Longest Increasing subsequence

Dynamic Programming
Starting from the end, going backward, and another pointer start from that index going forward, update output

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        LIS = [1] * len(nums)

        for i in range(len(nums)-1, -1, -1):
            for j in range(i+1, len(nums)):
                if nums[i] < nums[j]:
                    LIS[i] = max(LIS[i], 1 + LIS[j])

        return max(LIS)

# time: O(n^2), space: O(n)


################################### PROBLEM 309 ###################################

states: held: holds a stock bought before
        sold: just sold a stock right before entering this state. no stock at hand
        reset: 1. starting point 2. transient state before held and sold
action: buy, sell, rest

sold[i] = held[i-1] + prices[i]
held[i] = max(held[i-1], reset[i-1] - prices[i])
reset[i] = max(reset[i-1], sold[i-1])


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        sold = float('-inf')
        held = float('-inf')
        reset = 0

        for price in prices:
            prev_sold = sold
            sold = held + price
            held = max(held, reset - price)
            reset = max(reset, prev_sold)

        return max(reset, sold)

time: O(n), space: O(1)



################################### PROBLEM 347 ###################################
O(nlogn): Hashmap + Sort
O(klogn): Hashmap + max Heap
O(n): Bucket Sort  https://www.youtube.com/watch?v=YPTqKIgVk-k   space: O(n)

input: [1,1,1,2,2,3,100]

count :    1        2    3   4   5   6
values: [3, 100]   [2]  [1]  []  []  []


class Solution:                                  # Bucket Sort
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)]

        for num in nums:
            count[num] = count.get(num, 0) + 1

        for n, c in count.items():
            freq[c].append(n)

        res = []
        for i in range(len(freq) - 1, 0, -1):     # worst time complexity: O(n) + O(n):
            for n in freq[i]:                     # since the sum of freq is n
                res.append(n)
                if len(res) == k:
                    return res


from collections import Counter
class Solution:                                   # Heap
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # O(1) time
        if k == len(nums):
            return nums

        # 1. build hash map : character and how often it appears
        # O(N) time
        count = Counter(nums)
        # 2-3. build heap of top k frequent elements and
        # convert it into an output array
        # O(N log k) time
        return heapq.nlargest(k, count.keys(), key=count.get)



class Solution:                                   # Sort
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        hashmap = {}

        for num in nums:
            hashmap[num] = hashmap.get(num, 0) + 1

        sorted_hashmap = sorted(hashmap.items(), key = lambda x: x[1], reverse = True)
        # sorted function returns a list
        sorted_keys = [key for key, value in sorted_hashmap]

        return sorted_keys[:k]

################################### PROBLEM 370 ###################################

Prefix SUM

class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:
        res = [0] * length

        for start_idx, end_idx, inc in updates:
            res[start_idx] += inc
            if end_idx + 1 < length:
                res[end_idx + 1] -= inc

        for i in range(1, length):
            res[i] += res[i-1]

        return res


Time complexity : O(n+k). Each of the kkk update operations is done in constant O(1) time. The final cumulative sum transformation takes O(n) time always.
Space complexity : O(1). No extra space required.


The idea of the solution is to use the concept of "difference array" to perform range updates on the given array.

In a difference array, we store the difference between the consecutive elements of the original array.
For example, if the given array is [1, 2, 3, 4, 5], then the difference array would be [1, 1, 1, 1, 1],
since the difference between consecutive elements is always 1. Now, if we want to increment the elements
between index 2 and 4 (inclusive) by 2, we can simply update the difference array as [1, 1, 3, 1, 1].
We can then reconstruct the original array from the difference array by taking the cumulative sum.

Using this idea, we can efficiently perform range updates on the given array. In the given problem,
we need to perform multiple range updates on the array. We can store these updates in a separate "difference array" and
update the original array accordingly. Finally, we can take the cumulative sum of the difference array to get the final result.


################################### PROBLEM 380 ###################################

Use hashmap and a array together. Hashmap {key = num, value = index of the num in the array}

class RandomizedSet:

    def __init__(self):
        self.val_to_index = {}
        self.vals = []

    def insert(self, val: int) -> bool:
        if val in self.val_to_index:
            return False
        self.val_to_index[val] = len(self.vals)
        self.vals.append(val)
        return True

    def remove(self, val: int) -> bool:
        if val not in self.val_to_index:
            return False
        index = self.val_to_index[val]
        last_val = self.vals[-1]
        self.val_to_index[last_val] = index
        self.vals[index] = last_val
        self.vals.pop()
        del self.val_to_index(val)
        return True


    def getRandom(self) -> int:
        return random.choice(self.vals)


################################### PROBLEM 424 ###################################
Sliding Window

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        lookup = {} # key: character, value: count
        max_length = 0

        left = 0
        for right in range(len(s)):
            lookup[s[right]] = 1 + lookup.get(s[right], 0)
            while (right - left + 1) - max(lookup.values()) > k:
                lookup[s[left]] -= 1
                left += 1
            max_length = max(max_length, right - left + 1)

        return max_length

# time: O()




################################### PROBLEM 456 ###################################
Monotonic Stack

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack = []  # pair [num, minValue so far to the left], mono decreasing
        curr_min = nums[0]

        for num in nums[1:]:
            while stack and num >= stack[-1][0]:
                stack.pop()

            # when exiting above while loop, we either have an empty stack or num < stack[-1][0]
            # num is the k value we are looking for
            # if stack and num < stack[-1][0] and num > stack[-1][1]:

            if stack and num > stack[-1][1]:
                return True

            stack.append([num, curr_min])
            curr_min = min(curr_min, num)  # update curr_min after appending, because we want the minimum before the current number


        return False


################################### PROBLEM 463 ###################################
DFS

class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        if not grid or len(grid[0]) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])
        perimeter = 0

        for i in range(rows):
            for j in range(cols):
                if grid[i][i] == 1:
                    perimeter += self.dfs(grid, i, j)

        return perimeter

    def dfs(self, grid, i, j):
        # if we are at the boundary or reach to the water
        if i == -1 or i == len(grid) or j == -1 or j == len(grid[0]) or grid[i][j] == 0:
            return 1          # count the edge that is part of the perimeter

        if grid[i][j] == -1:  # already visited
            return 0
        grid[i][j] = -1       # mark as visited

        perimeter = 0
        perimeter += self.dfs(grid, i-1, j)
        perimeter += self.dfs(grid, i+1, j)
        perimeter += self.dfs(grid, i, j-1)
        perimeter += self.dfs(grid, i, j+1)

        return perimeter


BFS


from collections import deque

class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0

        rows, cols = len(grid), len(grid[0])
        visited = set()
        perimeter = 0

        # find the first island cell
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1 and (i, j) not in visited:
                    # start BFS from this island cell
                    queue = deque([(i, j)])
                    visited.add((i, j))

                    while queue:
                        x, y = queue.popleft()

                        # check the neighbors of the current cell
                        for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:
                            nx, ny = x + dx, y + dy
                            if nx == -1 or nx = len(grid) or ny == -1 or ny == len(grid[0]) or grid[nx][ny] == 0:
                                perimeter += 1  # count the edge that is part of perimeter
                            elif (nx, ny) not in visited:
                                queue.append((nx, ny))
                                visited.add((nx, ny))

        return perimeter


################################### PROBLEM 490 ###################################

class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        if not maze or not maze[0]:
            return False

        rows, cols = len(maze), len(maze[0])
        visited = set()
        return self.dfs(maze, tuple(start), tuple(destination), visited, rows, cols)

    def dfs(self, maze, start, destination, visited, rows, cols):
        if start == destination:
            return True

        if start in visited:
            return False

        visited.add(start)         # Mark the current cell as visited
        x, y = start

        # Move up
        while x > 0 and maze[x-1][y] == 0:       # Keep moving up until a wall or border is hit
            x -= 1
        if self.dfs(maze, (x, y), destination, visited, rows, cols):
            return True

        # Move down
        x, y = start     # Go back to the starting point if the previous moving doesn't work
        while x < rows - 1 and maze[x+1][y] == 0:
            x += 1
        if self.dfs(maze, (x, y), destination, visited, rows, cols):
            return True

        # Move left
        x, y = start
        while y > 0 and maze[x][y-1] == 0:
            y -= 1
        if self.dfs(maze, (x, y), destination, visited, rows, cols):
            return True

        # Move right
        x, y = start
        while y < cols - 1 and maze[x][y+1] == 0:
            y += 1
        if self.dfs(maze, (x, y), destination, visited, rows, cols):
            return True

        return False     # If none of the directions lead to the destination, return False


# time: O(m * n * max(m, n))
# space: O(m * n)


################################### PROBLEM 490 Review ###################################

class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        rows, cols = len(maze), len(maze[0])

        return self.dfs(maze, start[0], start[1], destination)

    def dfs(self, maze, i, j, destination)
        if i < 0 or i >= len(maze) or j < 0 or j >= len(maze[0]) or



################################### PROBLEM 496 ###################################
Monotonic Stack
# See circular array for problem 503

You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.

class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        mapper = { value: index for index, value in enumerate(nums1)}
        res = [-1] * n

        for num in num2:
            while stack and stack[-1] < num:
                res[mapper[stack[-1]]] = num
                stack.pop()

            if num in mapper:
                mapper.append(num)

        return res

################################### PROBLEM 503 ###################################
Monotonic Stack

class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:


################################### PROBLEM 516 ###################################
DYNAMIC PROGRAMMING

The outer loop iterates over the possible lengths of the substrings (from 1 to n), while the inner loop
iterates over the starting index of the substring.

class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)

        dp = [[0 for _ in range(n)] for _ in range(n)]

        for length in range(1, n+1):
            for i in range(n-length+1):
                j = i + length - 1
                if i == j:
                    dp[i][j] = 1
                    continue       # this continue is very important! Don't forget!
                                   # when length is 1, no need to check s[i] == s[j]

                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])

        return dp[0][n-1]




################################### PROBLEM 560 ###################################

Prefix Sum and Hash Table
# use the hash table to store the number the current prefix sum occurs so far


class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        prefix_sum = {0: 1}

        res = 0
        curr_sum = 0

        for num in nums:
            curr_sum += num
            if curr_sum - k in prefix_sum:
                res += prefix_sum[curr_sum - k]
            prefix_sum[curr_sum] = prefix_sum.get(curr_sum, 0) + 1

        return res


# time: O(n) Space: O(n)

################################### PROBLEM 567 ###################################
Sliding Window

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False

        s1map = [0] * 26
        s2map = [0] * 26

        for i in range(len(s1)):
            s1map[ord(s1[i]) - ord('a')] += 1
            s2map[ord(s2[i]) - ord('a')] += 1

        for i in range(len(s1), len(s2)):
            if self.matches(s1map, s2map):
                return True
            s2map[ord(s2[i]) - ord('a')] += 1
            s2map[ord(s2[i - len(s1)]) - ord('a')] -= 1

        return self.matches(s1map, s2map)

    def matches(self, s1map, s2map):
        for i in range(26):
            if s1map[i] != s2map[i]:
                return False
        return True


# time: O(26 * n)
################################### PROBLEM 647 ###################################

class Solution:
    def countSubstrings(self, s: str) -> int:
        if not s:
            return 0

        count = 0

        for i in range(len(s)):
            # odd length palindromes
            left, right = i, i
            while left >= 0 and right <= len(s) - 1 and s[left] == s[right]:
                count += 1
                left -= 1
                right += 1

            # even length palindromes
            left, right = i, i + 1
            while left >= 0 and right <= len(s) - 1 and s[left] == s[right]:
                count += 1
                left -= 1
                right += 1

        return count




################################### PROBLEM 680 ###################################
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def check_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        i = 0
        j = len(s) - 1
        while i < j:
            if s[i] != s[j]:
                return check_palindrome(s, i+1, j) or check_palindrome(s, i, j-1)
            i += 1
            j -= 1

        return True


Extension: what if we allow at most n deletions?

class Solution:
    def validPalindrome(self, s: str, n: int) -> bool:
        def check_palidrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        i = 0
        j = len(s) - 1
        changes = 0
        while i < j:
            if s[i] != s[j]:
                if changes >= n:
                    return False
                if check_palidrome(s, i+1, j):
                    i += 1
                    changes += 1
                elif check_palidrome(s, i, j-1):
                    j -= 1
                    changes += 1
                else:
                    return False

            i += 1
            j -= 1

        return True


################################### PROBLEM 694 ###################################
DFS

class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0

        rows, cols = len(grid), len(grid[0])
        shape_of_islands = set()

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:    # (i, j) is the topleft-most element
                    shape = []
                    self.dfs(grid, i, j, shape)
                    shape = [(x-i, y-j) for x, y in shape]
                    shape_of_islands.add(tupe(sorted(shape)))

        return len(shape_of_islands)

    def dfs(self, grid, i, j, shape):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
            return

        grid[i][j] = 0
        shape.append((i, j))

        self.dfs(grid, i-1, j, shape)
        self.dfs(grid, i+1, j, shape)
        self.dfs(grid, i, j-1, shape)
        self.dfs(grid, i, j+1, shape)



################################### PROBLEM 695 ###################################
DFS

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid or len(grid[0]) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])
        max_area = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    max_area = max(max_area, self.dfs(grid, i, j))
        return max_area

    def dfs(self, grid, i, j):
        if i == -1 or i == len(grid) or j == -1 or j == len(grid[0]) or grid[i][j] == 0:
            return 0

        grid[i][j] = 0  # mark as visited
        area = 1        # NOTE HERE, area is intiated 1, not 0

        area += self.dfs(grid, i-1, j)
        area += self.dfs(grid, i+1, j)
        area += self.dfs(grid, i, j-1)
        area += self.dfs(grid, i, j+1)

        return area


BFS

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid or len(grid[0]) == 0:
            return 0

        max_area = 0
        rows, cols = len(grid), len(grid[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        for i in range(rows):
            for j in range(cols):
                if grid[i][i] == 1:
                    area = 1
                    grid[i][j] = 0
                    queue = [(i, j)]

                    while queue:
                        curr_i, curr_j = queue.pop(0)

                        for di, dj in directions:
                            ni, nj = curr_i + di, curr_j + dj
                            if ni >= 0 and ni < rows and nj >= 0 and nj < cols and grid[ni][nj] == 1:
                                area += 1
                                grid[ni][nj] = 0
                                queue.append((ni, nj))

                max_area = max(max_area, area)

        return max_area


################################### PROBLEM 735 ###################################
Monotonic Stack

class Solution(object):
    def asteroidCollision(self, asteroids):
        stack = []

        for a in asteriods:
            while stack and a < 0 and stack[-1] > 0:
                diff = a + stack[-1]
                if diff < 0:
                    stack.pop()
                elif diff > 0:
                    a = 0                # assign a to 0 s.t. a won't append to stack
                else:
                    a = 0
                    stack.pop()

            if a:
                stack.append(a)

        return stack


################################### PROBLEM 714 ###################################

At the end of the i-th day, we maintain cash, the maximum profit we could have if we did not have a share of stock,
and hold, the maximum profit we could have if we owned a share of stock.


cash[i] = max(cash[i-1], hold[i-1] + prices[i] - fee)

not wrong: hold[i] = max(hold[i-1], cash[i-1] - prices[i])
more correct: hold[i] = max(hold[i-1], cash[i] - prices[i])

cash(i) - prices[i] => because cash(i) >= cash(i-1), if selling stock on day(i) results in more cash in hand than cash(i-1),
it makes sense to sell it on day(i) and buy it back instead of selling it on day(i-1) and buy it on day(i).



class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:

        n = len(prices)

        cash = 0
        hold = -prices[0]

        for i in range(1, n):
            prev_cash = cash
            cash = max(cash, hold + prices[i] - fee)
            hold = max(hold, prev_cash - prices[i])

        return cash

################################### PROBLEM 739 ###################################
Monotonic Stack

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []    # pair (temperature, index)

        for i, temp in enumerate(temperatures):
            while stack and temp > stack[-1][0]:
                stack_temp, stack_idx = stack.pop()
                res[stack_idx] = i - stack_idx
            stack.append((temp, i))

        return res



################################### PROBLEM 852 ###################################
Binary Search

class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        # find the first index s.t. nums[mid] < nums[mid-1]. mid - 1 is the idx for the maximum
        left, right = 0, len(arr)

        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < arr[mid-1]:
                right = mid
            else:
                left = mid + 1

        return left - 1



################################### PROBLEM 867 ###################################
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        rows = len(matrix)
        cols = len(matrix[0])

        transposed = [[0] * rows for _ in range(cols)]

        for i in range(rows):
            for j in range(cols):
                transposed[j][i] = matrix[i][j]

        return transposed



what if the matrix is square matrix?

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:

################################### PROBLEM 901 ###################################
Monotonic Stack

# Keep a decreasing monotonic stack.

class StockSpanner:

    def __init__(self):
        self.stack = []       # save pair: [price, span]

    def next(self, price: int) -> int:
        span = 1

        while self.stack and self.stack[-1][0] <= price:
            span += self.stack[-1][1]
            self.stack.pop()

        self.stack.append([price, span])
        # return span
        return self.stack[-1][1]




# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)


################################### PROBLEM 921 ###################################
Stack

class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        stack = []
        for char in s:
            if char == '(':
                stack.append('(')
            else:
                top_element = stack[-1] if stack else '#'
                if top_element == '(':
                    stack.pop()
                else:
                    stack.append(char)
        return len(stack)



################################### PROBLEM 974 ###################################

Prefix sum and hash table
# Using a prefix sum approach along with a hash table to store the frequency of prefixes that are congruent to the same value modulo k.


class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        reminderdict = {0: 1}

        count = 0
        curr_sum = 0

        for num in nums:
            curr_sum += num
            reminder = curr_sum % k
            if reminder in reminderdict:
                count += reminderdict[reminder]
            reminderdict[reminder] = reminderdict.get(reminder, 0) + 1

        return count


# time: O(n) Space: O(k)



################################### PROBLEM 1254 ###################################
DFS

class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0

        rows, cols = len(grid), len(grid[0])
        count = 0

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 0:
                    # if we find an unvistied land cell, performs DFS to check if it's a closed island
                    if self.dfs(grid, i, j):
                        count += 1

        return count

    def dfs(self, grid, i, j):
        # if we reach an edge, then the cell is not part of a closed island
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):
            return False
        # if we reach a water cell, then the cell is part of a closed island
        if grid[i][j] == 1:
            return True

        # mark the current cell as visited by setting it to 1
        grid[i][j] == 1

        # check if the surrounding cells forms a closed island
        up = self.dfs(grid, i-1, j)
        down = self.dfs(grid, i+1, j)
        left = self.dfs(grid, i, j-1)
        right = self.dfs(grid, i, j+1)

        return up and down and left and right


################################### PROBLEM 1614 ###################################

STACK

class Solution:
    def maxDepth(self, s: str) -> int:
        stack = []
        max_depth = 0

        for char in s:
            if char == '(':
                stack.append('(')
                max_depth = max(max_depth, len(stack))
            elif char == ')':
                stack.pop()
            else:
                continue

        return max_depth

      # instead of using extra space saving stack, can just use a variable
        def maxDepth(self, s: str) -> int:
            current_depth = 0
            max_depth = 0

            for char in s:
                if char == '(':
                    current_depth += 1
                    max_depth = max(max_depth, current_depth)
                elif char == ')':
                    current_depth -= 1

            return max_depth
